### 1. Добавление элемента в nil map

Перед начал использования map она ОБЯЗАТЕЛЬНО должна быть создана либо через make(), либо как литерал. Примеры в
разделе [Мапы](../note/map.md)

```go
package main

func main() {
	var m map[string]int
	m["one"] = 1 // ошибка
}
```

### 2. Получение элемента мапы и идиома "comma ok"

Иногда начинающие разработчики совершают ошибку, когда, обращаясь к несуществующему ключу мапы, ожидают получить
nil-значение (как это происходит в некоторых языках).
Возвращаемое значение будет nil, если «нулевое значение» (дефолтное) для соответствующего типа данных — nil.
Самый надёжный способ узнать, существует ли запись, — проверить второе значение, возвращаемое операцией доступа к
таблице.
Это так называемая "comma ok" идиома. В результате вернется 2 значения: 1 - значение в мапе по ключу (либо дефолтное,
если таковое отсутствует)
и 2 - булевский флаг, который показывает, существует ли такой ключ в мапе.

```go
package main

import "fmt"

func main() {
	x := map[string]string{"one": "a", "two": "", "three": "c"}

	if v := x["two"]; v == "" { // некорректно, поскольку дефолтным значением строки является пустая строка. Потенциальная угроза
		fmt.Println("no entry") // в консоль будет выведена запись "no entry"
	}
}
```

```go
package main

import "fmt"

func main() {
	x := map[string]string{"one": "a", "two": "", "three": "c"}

	if _, ok := x["two"]; !ok { // правильное решение
		fmt.Println("no entry")
	}
}
```

### 3. Передача map функцию

Напомним, что в Go все передается по значению. Мапа является ссылочным типом данных и казалось бы, что в функцию должна
передаваться ссылка.
На самом деле, в функцию передается копия ссылка. Это значит, что внутри функции все изменения, производимые с мапой,
будут отражены и на исходной.

```go
package main

func modifyMap(m map[int]string) {
	m[10] = "ten"
}

func main() {
	m := map[int]string{1: "x"} // map[1:x]
	modifyMap(m)                // map[1:x, 10:ten]
}
```

### 4. Обновление полей значений в хеш-таблице

Если есть мапа, состоящая из структур, то невозможно обновлять отдельные структурные поля. Код ниже не работает, потому
что элементы таблицы не адресуемы.

```go
package main

type data struct {
	name string
}

func main() {
	m := map[string]data{"x": {"one"}}
	m["x"].name = "two" // error
}
```

Обходные решения:

```go
package main

import "fmt"

type data struct {
	name string
}

func main() {
	m := map[string]data{"x": {"one"}}
	r := m["x"] // временная переменная
	r.name = "two"
	m["x"] = r
	fmt.Printf("%v", m) // выводит: map[x:{two}]
}
```

```go
package main

import "fmt"

type data struct {
	name string
}

func main() {
	m := map[string]*data{"x": {"one"}} // мапа с указателями
	m["x"].name = "two"                 //ok
	fmt.Println(m["x"])                 //выводит: &{two}
}
```

А вот код ниже вывалится с паникой, поскольку такого ключа в мапе не существует, соответственно вернется nil, а
обращение к полям nil-объекта - это плохо!

```go
package main

type data struct {
	name string
}

func main() {
	m := map[string]*data{"x": {"one"}}
	m["z"].name = "what?" // panic: runtime error: invalid memory address or nil pointer dereference
}
```



