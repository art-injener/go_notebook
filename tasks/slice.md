### 1. Итерация по слайсу

Итерация с копированием значений слайса

```go
type myStruct struct {
    h     uint64
    cache [64]byte
    raw   []byte
}

func main() {
   sl := make([]myStruct,10)

    for i := 0; i < 10; i++ {
        sl[i].h = uint64(i)
        sl[i].raw = make([]byte, 1024*1024)
    }
	
    var sum uint64 = 0
    for _, v := range sl {
        sum += v.h
   }
}
```

Итерация без копирования

1. Вариант

```go
type myStruct struct {
    h     uint64
    cache [64]byte
    raw   []byte
}

func main() {
    sl := make([]myStruct,10)

    for i := 0; i < 10; i++ {
        sl[i].h = uint64(i)
        sl[i].raw = make([]byte, 1024*1024)
    }
	
    var sum uint64 = 0
    for i := range sl {
        sum += sl[i].h
   }
}
```

2. Вариант

```go
type myStruct struct {
    h     uint64
    cache [64]byte
    raw   []byte
}

func main() {
    sl := make([]myStruct,10)

    for i := 0; i < 10; i++ {
        sl[i].h = uint64(i)
        sl[i].raw = make([]byte, 1024*1024)
    }
	
    var sum uint64 = 0
    for ii := range sl {
        sum += (&sl[ii]).h
   }
}
```

### 2. Склейка 2-х слайсов
```go
func main() {
    arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}
    arr2 := []int{20, 21, 22}
    arr2 = append(arr2, arr...)
    fmt.Println(arr2)
}
```

### 3. Передача слайса в функцию

1. Вариант
```go
func main() {
    arr := make([]int, 2, 10)
    
    arr[0] = 111 // 1
    arr[1] = 222

    Add(arr)
    
    fmt.Println("arr", arr) // 3
    fmt.Println("arr", arr[:cap(arr)]) // 4
    fmt.Println("len(arr)", len(arr))
    fmt.Println("cap(arr)", cap(arr))
}

func Add(v []int) {
     v = append(v, 1024, 1025, 1026, 1027) // 2
}
```

Вывод:

`arr [111 222]`

`arr [111 222 1024 1025 1026 1027 0 0 0 0]`

`len(arr) 2`

`cap(arr) 10`

Пояснения :

    1. Обновляем значения первых 2-х элементов
    2. Выполняется append, но без выделения памяти под новый слайс, потому что cap < количества добавляемых значений
    3. Выводится массив согласно len
    4. Операция слайсинга, по cap. Что позволяет заглянуть за границу len

2. Вариант
```go
func main() {
    arr := make([]int, 2, 10)
    
    arr[0] = 111 // 1
    arr[1] = 222

    Add(arr)
    
    fmt.Println("arr", arr) // 3
    fmt.Println("arr", arr[:cap(arr)]) // 4
    fmt.Println("len(arr)", len(arr))
    fmt.Println("cap(arr)", cap(arr))
}

func Add(v []int) {
     v = append(v, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032) // 2
}
```
Вывод:

`arr [111 222]`

`len(arr) 2`

`cap(arr) 10`

`arr [111 222 0 0 0 0 0 0 0 0]`

Пояснения:

    1. Обновляем значения первых 2-х элементов
    2. Выполняется append, происходит перевыделение памяти
    3. Выводится массив согласно len
    4. Операция слайсинга, по cap, но так как внутри функции был создан новый массив, изменения в исходном массиве не произошли 

3.  Вариант

```go
func main() {
    arr := make([]int, 5, 10)
	
    Add(arr[1:4]) // 1
	
    fmt.Println("arr", arr) // 5
    fmt.Println("len(arr)", len(arr)) // 6
    fmt.Println("cap(arr)", cap(arr)) // 7 
    fmt.Println("arr", arr[:cap(arr)]) // 9
}

func Add(v []int) {
    fmt.Println("len(arr) in Add", len(v)) // 2 
    fmt.Println("cap(arr) in Add", cap(v)) // 3 
    v = append(v, 1024, 1025, 1026, 1027, 1028) // 4
}
```

Вывод:

`len(arr) in Add 3`

`cap(arr) in Add 9`

`arr [0 0 0 0 1024]`

`len(arr) 5`

`cap(arr) 10`

`arr [0 0 0 0 1024 1025 1026 1027 1028 0]`

Пояснения:

    1 - 3. Выполняем операцию слайсинга. Получаем массив длиной 3 элеменета, при это емкость будет равна 9 (исходной емкости - 1), 
        потому что берем подслайс с 1 элемента, а не с 0.
    4. Добавление элементов не вызывает перевыделение памяти
    5 - 7. исходная длина будет такой же, как и емкость. Сам массив будет изменен 

### 4. Подводные камни слайсинга

```go
func main() {
    s1 := make([]int, 1)
    s2 := s1
    s2[0] = 1
    s1 = append(s1, 42)
    s2[0] = 21
    fmt.Println("s1", s1)
    fmt.Println("s2", s2)
}
```
Вывод: 
```
s1 [1 42]
s2 [21]
```

Пояснение:

При выполнении операции `s1 = append(s1, 42)`, будет создан новый слайс. И s2 ни как не будет на него влиять.  

### 5. Писькодрочерство

```go
func main() {
    ts := [2]T{}
    for i := range ts[:] {
        switch t := &ts[i]; i {
        case 0:
            t.n = 3
            ts[1].n = 9
        case 1:
            fmt.Print(t.n, "")
        }
    }
    fmt.Print(ts)
}
```

Пояснение:

В range мы делаем копию того, что перебираем. Могут быть нюансы. Но тут мы работаем с индексами и все норм!
Далее в switch мы получаем ссылку на элемент. Но это switch и все в одной области видимости.
Также, обращение к элементам массива происходит либо по ссылке на сам объект, либо через индекс, и мы меняем сам объект,
а не копию.
Ну и принт (Не принтЛн) все выводит в строку.
________________________________________________________________

```go
func main() {
	var a []int = nil
	a, a[0] = []int{1, 2, 3}, 9
fmt.Println(a)
}
```

Пояснение:

Здесь действует простое правило - выражение вычисляется позже, чем его подвыражения.
Мы сначала пытаемся записать под нулевым индексом в nil-массив элемент, а затем заполняем его {1, 2}.
Получаем ошибку panic: runtime error: index out of range [0] with length 0.

### 6. Добавление элементов в слайс

#### 6.1 При len = 10 и cap = 10

```go
func main() {
arr := make([]int, 10)

for i := 0; i < 10; i++ {
arr = append(arr, i)
}

fmt.Println(arr)
}
```

Вывод:

```
[0 0 0 0 0 0 0 0 0 0 0 1 2 3 4 5 6 7 8 9]
```

Пояснение:

при таком способе создания слайса автоматически будет выделено место под 10 элементов с дефолтным значением каждого.
При добавлении очередного элемента он будет вставлен в конец слайса, в данном случае на 10-е место и т.д

#### 6.2 При len = 0 и cap = 10

```go
func main() {
arr := make([]int, 0, 10)

for i := 0; i < 10; i++ {
arr = append(arr, i)
}

fmt.Println(arr)
}
```

Вывод:

```
[0 1 2 3 4 5 6 7 8 9]
```

Пояснение:

при таком подходе изначально будет выделено памяти под 10 элементов, но длина слайса при этом будет равна 0.
Соответственно при добавлении элемента вставка будет производиться с начала.

### 7. Увеличение емкости cap при последовательном добавлении элементов

```go
func main() {
arr := make([]int, 0)
fmt.Printf("len = %d, cap = %d\n", len(arr), cap(arr))
for i := 0; i < 2000; i++ {
arr = append(arr, i)
fmt.Printf("len = %d, cap = %d\n", len(arr), cap(arr))
}
}
```

Вывод:

```
len = 0, cap = 0
len = 1, cap = 1  
len = 2, cap = 2  
...  
len = 4, cap = 4  
len = 5, cap = 8  
...
len = 8, cap = 8  
len = 9, cap = 16
...
len = 16, cap = 16
len = 17, cap = 32
...
len = 32, cap = 32
len = 33, cap = 64
...
len = 64, cap = 64
len = 65, cap = 128
...
len = 128, cap = 128
len = 129, cap = 256
...
len = 256, cap = 256
len = 257, cap = 512
...
len = 512, cap = 512
len = 513, cap = 1024
...
len = 1024, cap = 1024
len = 1025, cap = 1280
...
len = 1280, cap = 1280
len = 1281, cap = 1696
...
len = 1697, cap = 2304
...
len = 2000, cap = 2304
```

Пояснение:

как можно заменить, емкость слайса увеличивается в 2 раза при достижении верхней границы.
Но эта закономерность работает до тех пор, пока количество элементов в слайсе не достигнет 1024.
После этого емкость будет увеличиваться на 12,5%.

### 8. Добавление в nil слайс

```go
func main() {
var arr []int
fmt.Println("slice before: ", arr)
fmt.Printf("len = %d, cap = %d\n", len(arr), cap(arr))

arr = append(arr, 10)
fmt.Println("slice after: ", arr)
fmt.Printf("len = %d, cap = %d", len(arr), cap(arr))
}
```

Вывод:

```
slice before:  []
len = 0, cap = 0  
slice after:  [10]
len = 1, cap = 1 
```

Пояснение:

Нулевым значением для слайса равно nil. И оно валидно! Но это не значит, что ничего нельзя с этим сделать.
В Go типы могут фактически использоваться, когда значение равно нулю. При добавлении нового элемента в nil-слайс
под капотом произойдет выделение памяти под элемент, вставка элемента и увеличение значения длины и емкости.

### 9. Добавление в nil слайс

```go
func main() {
arr := make([]int, 10, 5)
fmt.Println(arr)
}
```

Вывод:

```
len larger than cap in make([]int)
```

Пояснение:

Самое интересное, что будет ошибка runtime, а не компиляции. В принципе, аналогично определяется ошибка выхода за
границы слайса при обращении к несуществующему индексу

## Запомнить!

Слайс - это НЕ сравниваемый тип, поэтому в качестве ключей к мапе не используется (это на будущее)

## Интересненько

```go
func main() {
arr1 := make([]int, 0, 10)

for i := 0; i < 10; i++ {
arr1 = append(arr1, i)
}

fmt.Println(arr1[2:6:8])
}
```

Вывод:

```
[2 3 4 5]
```

Это вполне валидная конструкция. В результате ":8" не будет браться в рассчет и вернутся элементы со 2 по 6.
Но arr1[2:6:8:10] уже не сработает, ошибка компиляции